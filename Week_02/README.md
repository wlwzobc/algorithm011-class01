#### **HashMap 小结**



HashMap是一种Map的实现版本。根据key的 hashCode 值来找到存储 value 的数组下标位置。是非线程安全的。

1. 存储结构

   数组。hash冲突解决方案：

   a. JDK 1.8 之前，链表。

   b. JDK 1.8 及之后，链表 + 红黑树。添加元素，当链表过长时（长度超过8，同时需要数组长度超过64），链表会升级成红黑树，此时，红黑树的查询成本更低。移除元素，当链表变短时（长度小于6，resize时），红黑树又会退化成链表。

2. hash函数

   为减少hash冲突，保留原 **hashCode** 的高低16为特征值，将 hashCode 值右移 16 位，与原 hashCode 使用位异或运算，得到新hashcode，再 **hashCode & (length - 1) **(相当于对数组长度去余)，得到数组下标索引。

3. 数组扩容

   HashMap底层数组，大小一定是2^n，其中一个原因就是方便数组的扩容。当底层数组需要扩容时，数组大小翻倍，下标计算变为：**hash & (oldTable.length * 2 - 1)**，新旧下标的结果，要不然就相同，要不然就是新下标等于旧下标加上旧数组的长度。e.hash & oldCap 只要其结果是0，则新散列下标就等于原散列下标，否则新散列坐标要在原散列坐标的基础上加上原table长度。



#### 学习总结



##### 哈希表、映射、集合

哈希表（Hash table），散列表，是根据关键码值（Key value）而直接进行访问的数据结构。 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。 这个映射函数叫作**散列函数**（Hash Function），存放记录的数组 叫作哈希表（或散列表）。

搜索、插入、删除的时间复杂度平均为O(1)，最差为O(n)，空间复杂度为O(n)。

Map：key-value对，key不重复；Set：不重复元素的集合



##### 树、二叉树、二叉搜索树

树(Tree)是元素的集合。有多个节点(node)，用以储存元素。某些节点之间存在一定的关系，用连线表示，连线称为边(edge)。边的上端节点称为父节点，下端称为子节点。树像是一个不断分叉的树根。与图的区别是，树没有闭环。

二叉树是一种特殊的数据结构，顾名思义，二叉树只有两个叉，也就是两个子节点：左子节点和右子节点。三种遍历方法：前序遍历、中序遍历和后序遍历。

二叉查找树（Binary Search Tree，BST）是一种特殊的二叉树，一棵二叉搜索树（BST）是一棵二叉树，其中，每个节点的值都要大于其左子树中任意节点的值而小于右子树中任意节点的值。



##### 堆和二叉堆

堆可以迅速找到一堆树中的最大或最小值的数据结构。基本要求是堆中所有结点的值必须大于等于（或小于等于）其孩子结点的值。是一棵完全二叉树。

二叉堆，通过完全二叉树来实现(不是二叉搜索树)。二叉堆(大顶)满足以下性质：是一颗完全树；树中任意节点的值总是>=其子节点的值。

使用时，我们可以直接从堆顶拿到最大/小值，插入，删除节点需要做相应的调整保证二叉堆的特性。



##### 图

图包含一组节点和边。这些节点也被称为顶点vertex。边edge用来连接节点，节点用来存储和取回数据。